<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>テキスト公開ページ｜貼り付け専用付き</title>
  <meta name="description" content="GitHub＆Netlifyに置ける、テキスト公開用の単一HTML。貼り付け→コピー→削除の一時置き場を搭載。" />
  <!-- 必要に応じてnoindexに切替してください。 -->
  <!-- <meta name="robots" content="noindex,nofollow" /> -->
  <style>
    :root { --bg:#0b1020; --card:#0f172a; --fg:#e5e7eb; --muted:#9ca3af; --acc:#60a5fa; --border:#1f2937; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0b1020 40%,#0f1324);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN",Meiryo,"Noto Sans JP",sans-serif;line-height:1.7;letter-spacing:.2px}
    .wrap{max-width:880px;margin:0 auto;padding:24px 16px 64px}
    header{position:sticky;top:0;z-index:20;backdrop-filter:blur(8px);background:linear-gradient(180deg,rgba(11,16,32,.9),rgba(11,16,32,.65));border-bottom:1px solid var(--border)}
    .head-inner{max-width:880px;margin:0 auto;padding:14px 16px;display:flex;gap:12px;align-items:center}
    h1{font-size:clamp(18px,2.4vw,24px);margin:0}
    .subtitle{color:var(--muted);font-size:12px}
    .toolbar{margin-left:auto;display:flex;gap:8px}
    button,input[type="search"]{border:1px solid var(--border);background:#0c1429;color:var(--fg);padding:8px 12px;border-radius:12px;font:inherit;outline:none}
    button:hover{border-color:#2b3a52;cursor:pointer}
    input[type="search"]{width:min(46vw,320px)}
    main{background:var(--card);border:1px solid var(--border);border-radius:20px;padding:20px;margin-top:18px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .meta{color:var(--muted);font-size:12px;margin-bottom:10px;display:flex;gap:10px;flex-wrap:wrap}
    .block{border:1px dashed #22304a;border-radius:14px;padding:16px;margin:12px 0;background:rgba(255,255,255,.02)}
    .block h2{font-size:clamp(16px,2.2vw,22px);margin:0 0 8px}
    .block .tag{font-size:11px;color:var(--muted)}
    .block p,.block li,.block pre,.block code{font-size:clamp(14px,1.9vw,16px)}
    .block a{color:var(--acc);text-decoration:none}
    .block a:hover{text-decoration:underline}
    details{border:1px solid #1e2a44;border-radius:12px;padding:12px 14px;background:rgba(255,255,255,.02)}
    details+details{margin-top:10px}
    summary{cursor:pointer;color:var(--fg)}
    pre{overflow:auto;padding:12px;background:#0a1224;border:1px solid var(--border);border-radius:10px}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    footer{color:var(--muted);text-align:center;font-size:12px;padding:24px 0 0}
    .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 6px}
    #pasteBox{width:100%;resize:vertical;border-radius:12px;padding:12px;background:#0a1224;color:var(--fg);border:1px solid var(--border)}
  </style>
</head>
<body>
  <header>
    <div class="head-inner">
      <div>
        <h1>テキスト公開ページ</h1>
        <div class="subtitle">GitHub / Netlify にそのままデプロイ可（単一HTML）</div>
      </div>
      <div class="toolbar">
        <input id="q" type="search" placeholder="ページ内検索…(テキストを絞り込み)" aria-label="検索" />
        <button id="copyAll" title="本文をすべてコピー">全コピー</button>
        <button id="toggleIndex" title="検索エンジンのインデックス制御">noindex切替</button>
      </div>
    </div>
  </header>

  <div class="wrap">
    <main>
      <div class="meta">
        <span>最終更新: <time id="updated"></time></span>
        <span id="indexState"></span>
      </div>

      <article id="content" aria-label="本文">
        <!-- ↓↓↓ この中に自由にテキストを追加してください ↓↓↓ -->

        <section class="block" data-tags="貼り付け 入力 コピー">
          <h2>■ 掲載データ（貼り付け→コピー→削除の一時置き場）</h2>
          <p>ここに<strong>テキストをそのまま貼り付け</strong>て使います。右上の <em>全コピー</em> はページ全体をコピーしますが、この枠専用の <strong>「この枠だけコピー」</strong> ボタンも用意しています。作業が終わったらこの枠の内容を削除してください。</p>
          <div class="row">
            <button id="copyBox">この枠だけコピー</button>
            <button id="selectBox">全選択</button>
            <button id="downloadBox">.txt で保存</button>
            <span class="tag" id="boxInfo" aria-live="polite"></span>
          </div>
          <textarea id="pasteBox" rows="32" spellcheck="false">
AI(人工知能)
	技術進化の系譜
		AIの発展史は、人間がルールを与えて推論させた第1世代（ルールベースAI）から、\nデータを使って自ら学ぶ第2世代（機械学習）、\nそして多層のニューラルネットワークで特徴を自動抽出する第3世代（ディープラーニング）へと進化してきた。
		第1世代：ルールベース（学習しない）
			概要：人が定義したルールに従って動作
			代表例：エキスパートシステム（if-thenルール）
				人間の知識を if〜then 形式で蓄積
				推論エンジンが条件から結論を導く
			特徴
				 学習しない（知識は人が与える）
				明示的なルールで動作（解釈性が高い）
			限界
				未知のデータや例外に対応できない
				知識入力の手間が膨大
		第2世代：機械学習（データから学ぶ）
			詳細説明は【抜粋】第2世代：機械学習　にまとめ
			概要：データを解析して規則やパターンを発見
			特徴
				統計的アプローチに基づく（学習アルゴリズム）
				特徴量設計（Feature Engineering）が重要
					特微量設計
						データを適切に加工・変換するプロセス
						機械学習モデルの性能を向上させるため
					特微量
						モデルが予測や分類を行う際に使用するデータの属性
						数値化された「判断材料」
					例：迷惑メール判定（「特定の単語の出現回数」や「URLの数」などが特徴量として利用）
					実践的なポイント
						ドメイン知識の活用
							対象分野の専門知識を活かして有用な特徴量を作
							ドメイン知識
								特定の業界や分野に関する専門的な知識
								分野に特化した概念や原則、用語、経験則を含む
						正規化・標準化
							特徴量間のスケールを揃えることで、学習の安定性を向上
						欠損値の処理
							モデルの性能低下を防ぐ
			限界
				特徴抽出を人が定義する必要あり（自動ではない）
			学習アプローチ
				教師あり学習
					正解データのペアを与えてモデルをトレーニング
				教師なし学習
					正解データのペアを与えず、モデルに自己でパターンや構造を発見させるトレーニング
				半教師あり学習
					少量の正解ベータ（ラベル付き）を用いて大量のラベルのない（未知の）データを効率的に学習
				強化学習
					行動と結果を繰り返し、報酬を最大化するよう学習
				転移学習
					既に学習済モデルの知識を別のタスクに再利用
						例：画像分類モデルを医療画像解析に応用
				補足
					各アプローチは目的・データ量・ラベルウムによって選択される
					ノーフリーランチ定理
						万能なアルゴリズムは存在せず、課題ごとに最適な手法が異なる
		第3世代：ディープラーニング（人間の脳を模倣）
			詳細説明は【抜粋】第3世代：ディープラーニング　にまとめ
			概要：多層のニューラルネットワークで特徴を自動抽出
			構造
				ニューラルネットワーク（全体構造）
					多数の人工ニューロンを多層化した構造
						人工ニューロン（ノード）
							入力を受け取り、重み・活性化を経て出力
							各入力の重要度を示す「重み」
							重み付けは誤差逆伝播で更新
								誤差逆伝播法（バックプロパゲーション）
									損失関数を最小化するためにパラメータ（重みやバイアス）を効率的に更新するアルゴリズム
									入力データが順伝播（フォワードプロパゲーション）によって出力層に伝わり、損失関数が計算
									その後、誤差逆伝播法を用いて、損失関数の勾配（偏微分）を計算し、重みとバイアスを更新
					ネットワーク層（構造を作る部品）
						データが層を通過しながら特徴を抽出・変換
							入力層
								外部データを取り込む
									例：画像のピクセル値やテキストの単語ベクトルなど。
							中間層
								特徴を抽出・変換
								複数のノードが重みと活性化関数を通して学習
							出力層
								最終的な予測や分類結果を出す層
									タスクに応じて出力形式が変わる（例：確率、数値、ラベルなど）
				活性化関数
					シグモイド関数／ReLU関数など
			特徴
				特徴量を自動抽出
				大量データ＋GPUで高精度学習
			限界
				学習コストが高い／解釈性が低い（ブラックボックス化）
				過学習・汎化性能のバランスが難しい
			過学習（オーバーフィッティング）
				学習データに特化しすぎて新しいデータに弱くなる
				過学習防止
					アーリーストッピング
						検証データの誤差が悪化し始めた時点で学習を打ち切る
					正則化
						重みの値を制限し、特定パターンへの依存を防ぐ
							L1正則化（Lasso）：重みを0に近づけて“特徴を絞る”。
							L2正則化（Ridge）：重みを全体的に小さくして“安定化”させる。
					ドロップアウト
						学習中に一部のノードをランダムで無効化して、依存を減らす
			第3世代（モデル）は、第2世代の学習方法を内部に引き継いで自動化した進化形
				第2世代の学習アプローチを内部で利用する新しい構造群
	【抜粋】第2世代：機械学習
		学習アプローチ（仕組み）
			教師あり学習
				 概要：正解データを用いて予測・分類を行う
				代用手法
					回帰/分類
					SVM（サポートベクターマシン）
					決定木／ランダムフォレスト
					特徴
						精度が高いが、データ整備コストが大きい
			教師なし学習
				概要：ラベルのないデータから構造を発見
					データ自体のパターンや構造を自ら発見しトレーニング
				アプローチ：パターン抽出
					クラスタリング
						類似性でグループ化（K-means／階層法）
							類似性やパターンを検出
							与えられたデータをグループに分類
							データの理解、分析、異常検知
					次元削減
						目的
							データの次元（変数）を減らす
							特徴だけを抽出
							最小限のデータを保持
							メリット
								データの可視化や解析が容易
								計算コストの削減
								モデルの性能向上（過学習を防ぐ）
						代表的手法
							主成分分析（PCA）
							t-SNE／LDA
				特徴
					可視化やデータ整理に有効
					モデル前処理や分析補助として利用
			半教師あり学習
				概要：少量のラベル付き＋大量のラベルなしで学習
				教師あり＋教師なしの中間的手法
				医療・文書・音声などラベル不足分野に有効
				学習コストを大幅削減
				応用
					画像分類
					医療・音声認識
			強化学習
				「報酬」という特定の目標を設定し、達成させるための最適な行動を学習
					例：経路探索のアルゴリズム
						距離の短さを報酬とすると、できるだけ距離が短い経路を学習していく
				メリット
					過程や行動を評価する場合に有効で、必ずしも大量のデータが必要ではないことがメリット
					◯✕で表すことが難しい過程に適している
				流れ
					試行錯誤を繰り返して最適な行動を学習
				応用
					ゲームAI（ALphaGo）
					自動運転・ロボット制御
				注意点
					報酬設計が難しい（Reward設計次第で学習が偏る）
			転移学習
	【抜粋】第3世代：ディープラーニング
		モデル系統（構造）
			分類・予測向けモデル（入力 → 特徴抽出 → 分類）
				CNN
					畳み込みニューラルネットワーク
						convolutional/畳み込み
							巻き込む/重ね合わせる/混ぜ合わせる
							「折りたたんで重ね合わせる」イメージ
							数学（信号処理）由来の比喩的表現
							画像の一部（小さな範囲）とフィルタを、重ね合わせながら順に計算していく
								例：カーペットを少しずつ畳みながら（ずらしながら）模様を確認していく
						neural/神経の
					画像認識
						画像特徴の検出・分類に活用
						仕組み
							画素を小さな領域（画素単位）で分割し、特徴を抽出
						入力
							画素の位置情報・色情報を通知データとして処理
						処理
							畳み込み層で画素の繋がり（特徴パターン）を学習
						出力
							対象の識別や分類結果を確立として出力
								Softmax関数（出力層の活性化関数）
				RNN
					再帰型ニューラルネットワーク
						Recurrent/繰り返し、再帰的
					音声認識・文章生成・時系列データの処理
					長期記憶が苦手
					自己回帰モデルの一種
				LSTM
					長・短期記憶
						Long Short-Term Memory
					長文処理・翻訳・音声認識など
					RNNの改良型。長期間の情報を保持できる構造
			生成モデル（特徴空間から新しいデータを生成）
				生成の源流（確率的NN）
					BM（ボルツマン マシン）
						ニューロンが確率的に ON/OFF、分布を再現
					RBM（制限付きボルツマン マシン）
						入力部分と推測部分の２つにわけることで効率化
					DBN（Deep Belief Network）
						RBMを多層に積層した初期Deep生成
				VAE
					Variational/変分的、Autoencoder/自己符号化
						変分的：極値問題（最大値・最小値）や最適化を扱う概念
					エンコーダ
						入力データを「潜在変数 z（特徴の確率分布）」に変換
					デコーダ
						潜在変数 z をもとに、元のデータに近い出力を再構成
					画像生成・異常検知
					基盤構造
						Encoder–Decoder（主にCNN等）
						Transformer利用: なし
				GAN
					敵対的生成ネットワーク
						Generative/生成的
							Adversarial/敵対的
					敵対的
						生成器は、識別器をだますようによりリアルなデータを生成する
						識別器は、本物と偽物を見分ける精度を高めようとする
					画像生成・データ拡張・Deepfakeなど
					基盤構造
						生成器・識別器（主にCNN等）
							生成器
								ノイズ（乱数）から新しいデータを生成する
							識別機
								入力データが「本物」か「生成されたもの」かを判定する
						Transformer利用: まれ
				Diffusionl
					Diffusion/拡散
					ノイズを加えて学習し、除去しながら生成
					Stable Diffusion／画像生成AIの主流手法
					基盤構造
						U-Net + Cross-Attn
						Transformer利用: 併用あり
						※Diffusion系は画像生成の一部で Cross-Attention に Transformerブロック併用が一般的（U-Netが主軸）
				テキスト生成モデル
					LM
						単語の出現確率を学習し、文脈に基づいて次の単語を予測する基礎モデ
						例：GPT(初代）など
					LLM
						大規模言語モデル
							Large/大規模
							Language/言語
							膨大なテキストデータを学習し、文脈理解・論理推論・創造的生成を行う
						基盤構造
							Transformer-Decoder（自己回帰）
							Transformer利用: あり
							自己回帰型Transformerによる文章生成
						入力設計
							プロンプト
								AIに与える指示文。出力内容・文体・視点・形式などを制御
								プロンプティングの基礎とAIの特性
									AIの特定
										言語パターンに基づく確率生成（理解ではなく統計的関連）
										会話履歴（コンテキスト）を参照しながら最適化
										厳格（ハルシネーション）などの誤生成を起こす可能性がある
									プロンプトの構成要素
										インストラクション（命令文）
											AIに行ってほしいことを明示する
										コンテキスト
											背景・前提・役割などを与える
										インプットデータ
											実際にAIに処理させる対象情報
										アウトプットインジケータ
											望ましい出力形式・制約を指定する
									プロンプト設計の種類（例示の有無による分類）
										Zero-Shotプロンプティング
											AIの事前学習知識に基づいて応答する
											例：次の文章を要約してください
											特徴：シンプル・早いが、あいまいな場合誤答しやすい
										One-Shotプロンプティング
											1つの例を提示して指示する方法
											例：以下の例のように分類してください：～
											特徴：出力形式を明示しやすく、安定度が上がる
										Few-Shotプロンプティング
											複数の例を提示してAIにパターンを学習させる方法
											例：以下の3つの例を参考に文章を分類してください：～
											特徴：殉難。高精度だが、プロンプトが長くなりやすい
							システムプロンプト/ユーザープロンプト
								システム：AIの役割・文体・人格などの初期設定
								ユーザー：実際の指示・質問部分（入力テキスト）
							出力制御パラメータ（生成多様性の調整）
								Temperature（テンプレチャー）
									出力のランダム性（創造性）を調整する温度設定
									低：安定・理論的
									高：創造的・多様
								top-p（核サンプリング）
									確率分布の上位p%の範囲から単語を選択
									低：限定的
									高：柔軟・多様
						代表的応用：生成AI（テキスト生成・対話）
							製品
								ChatGPT
									chat（対話型）
										G（Generative）：生成
											P（Pre-trained）：事前学習
												T（Transformer）：Transformerモデル
									機能的特徴
										文脈理解と継続的対話
										意図推定と自然な文章生成
										指示への適応（Instruct型）
										安全性とフィルタリング機構の導入
									世代
										GPT（初代）
											2018年
												TransformerのDecoderを採用
													自己回帰的に文章を生成（タスクごとに微調整必要）
										GPT-2
											2019年
												大規模化（15億パラメータ）
													微調整なしでも多様な文を生成可能
										GPT-3
											2020年
												超大規模（1,750億パラメータ）
													Few-shot学習（例示から汎化）を実現
										ChatGPT（GPT-3.5）
											2022年
												対話特化モデル
													RLHF（人間のフィードバックによる強化学習）導入
										GPT-4
											2023年
												マルチモーダル対応
													テキスト＋画像入力、精度・安全性の向上
													マルチモーダル：テキスト・画像、音声、動画など異なる種類のデータを一度に処理することを可能なAI技術
														文章と画像を合わせえて指示を出し、データを生成できるように
									RLHFにより対話最適化された代表モデル
										学習段階
											事前学習（Pre-training）
												大量のWeb文書・書籍・コードなどを用いて言語パターンを学習
											教師あり微調整（Supervised Fine-tuning）
												AIが出力した回答を人間が評価し、良い例を学習
											強化学習（Reinforcement Learning from Human Feedback：RLHF）
												人間が“望ましい回答”に報酬を与え、モデルがそれを最大化するよう最適化
										派生・拡張モデル
											GPTs（Custom GPT）
												ユーザーが目的別にプロンプト・知識・API連携を設定する
											GPT-4o（Omni-modal Model）
												「o」は omni＝全モード
												テキスト・画像・音声などを統合処理（入出力両対応）\n\n
												GPT-4系列の統合版で軽量・高速・多モーダル
									機能モード/ツール
										拡張機能（モデルではない）
										Code Interpreter
											Pythonを使用できるようになった
											自分でソースコード（コンピュータに与える命令）を書いて実行できるように
											原則オフライン
										Retrieval（ドキュメント検索・社内ベクトルDB連携）
										Browser／Plugin（Web参照・外部API接続）
										その他拡張モード（例：DALL-E生成、音声認識）
									限界
										正確性の保証がない（幻覚＝Hallucination）
										学習データの更新制約（知識のタイムラグ）
										倫理的・著作権上の懸念
								ChatGPT他の代表モデル
									Claude（Anthropic）
									Gemini（Google）\n\n
									LLaMA（Meta）
			Hybrid Model（複数の構造や手法を組み合わせた応用）
				高度な質問応答・生成支援AI
				例
					CNN＋RNN（映像解析など）
					Transformer＋Diffusion（高品質画像生成）
					ルールベース＋学習モデル（説明可能AIなど）
	人間との関係
		役割分担
			補完
				AIが人間の作業を支援
					翻訳
					データ集計
				代替
					AIが人間の一部の仕事を置き換える
						画像判定
						要約
				想像支援
					AIが新しい思想や表現を助ける
						文章・デザイン生成
		比較と限界
			AIの強み
				処理速度・精度・膨大なデータ分析
			人間の強み
				想像性・倫理判断・感情分析・価値観の成形
			限界
				データ外の判断・倫理的選択・想像力はAIには困難
		共存・協働
			ヒューマン・イン・ザ・ループ（HITL)
				AIの判断に人間が最終決定を加える仕組み
			人間中心設計（HCD)
				利用者の安全・快適さを重視したAI設計思想
			倫理・説明責任
				AIの判断過程を人間が理解・説明できるようにする
	社会的課題
		AI倫理
			公平性
				データやアルゴリズムの偏り（バイアス）を排除し、平等な判断を行う
			説明責任（アカウンタビリティ）
				AIの判断理由を人間が説明できるようにする
			信頼性
				AIが安定して正しい結果を出すこと
			透明性
				AIの仕組みや学習データを適切に公開・管理する
		法制度・ガバナンス
			AI規制・新法
				国際的にAI活用のルール整備が進行中（EU AI Actなど）
			個人情報保護
				個人データの利用・学習には制約がある（個人情報保護法など）
			著作権問題
				学習データや生成物の著作権の扱いが課題
			責任の所在
				AIが誤作動した際に「誰が責任を取るか」を明確化する必要
		社会的影響と課題
			雇用への影響
				一部の業務がAIに置き換えられるが、新な職種も生まれる
			偽情報・フェイク生成
				生成AIが誤情報を作り出すリスク
			教育・学習
				AIを適切に活用するリテラシー教育が重要
			デジタル・ディバイド
				技術格差によりAI活用機械が不均等になる
	応用領域
		画像認識
			CNNなどを用いて画像の特徴を自動抽出
			顔認識・医療画像診断・製品検査などに応用
			セキュリティ・スマートフォン・監視システムに利用
		音声認識
			コールセンター・音声アシスタント・自動字幕生成で活用
			音声合成（Text to Speech）との組み合わせで双方化
		自然言語処理（NLP)
			AIが「人間の言葉を理解・生成」するための技術領域
			主なタスク
				テキスト分類／要約／翻訳／質問応答／感情分析
				言語モデリング（Language Modeling）
			モデル利用
				LLMを中心に発展
					例：chatGPT、Bard（Gemini）、Claudeなど
			関連構造
				Transformr（自然言語処理の基盤構造
			学習プロセス（モデルの訓練段階）
				プレトレーニング
					大量のテキストを使って、文脈理解や単語関係などを事前学習
					例：BERTやGPTの基盤訓練
				ファインチューニング
					特定タスク向けに追加学習し、性能を最適化
					例：要約専用モデル、翻訳特化モデル
				RLHF
					ChatGPTで採用。人間評価をもとに応答品質を強化
		生成AI
			画像・動画・音声・文章などを自動生成する技術
			モデル利用：GAN／VAE／Diffusion Model など
			テキスト生成AI：ChatGPT、Claude、Gemini など
			応用領域：コンテンツ制作／広告／教育／研究支援
		医療・ヘルスケア
			CT画像診断・疾患予測・創薬支援などにAIを応用
			患者データの分析による治療方針支援
			倫理的配慮や説明責任の確保が求められる
		自動運転
			カメラ・センサー・AIが連携して周囲を認識
			強化学習を用いた安全な運転判断を学習
			人間の監視（ヒューマン・イン・ザ・ループ）が必要
		金融・ビジネス
			需要予測・不正検知・投資分析・リスク管理などに活用
			RPA（業務自動化）と組み合わせた省力化
			顧客対応chatボットや推薦システムに発展
		教育・クリエイティブ分野
			プロンプト設計を活用した想像支援（例：文章・画像・動画作成）
			学習教材作成・個別指導AI・スキル習得支援に応用
			教師や学生の"AIとの協働力"が重要視される
	未来展望
		シンギュラリティ（技術的得意点）
			人工知能が人間の知能を超える転換点
			予測時期：2045年前後とされる（レイ・カーワイル説）
			社会・産業・価値観の急変をもたらす可能性
		AIの進化方向
			ANI（Artifical Narrow Intelligence）
				特化型AI、特定分野に特化（例：画像判定・翻訳）
			AGI（Artifical General Intelligence）
				汎用型AI、人間のように多様な課題に対応
			ASI（Artifical Super Intteligence）
				超知能型AI、人間を大幅に超える能力
		人間との共存
			AIを活用した創造的協働（共創社会）
			倫理的AI設計の重要性（Human-Centered AI）
			ヒューマン・イン・コマンド（HIC）
				最終判断は人間が行う
		社会変革と課題
			労働・教育の再構築
				AIと共に働くスキルが求められる
			法・制度の進化
				AI新法やガイドラインの国際整備
			持続可能なAI
				環境負荷や倫理面に配慮した開発
		未来への視点
			「AIを使う力（AIリテラシー）」が全世代に必須となる
			「AIと人間の共創」が新しい価値を生む時代へ
			「恐れる対象」ではなく「共に設計・制御する技術」として向き合う

</textarea>
          <p class="tag">※ この枠は貼り付け→コピー→削除の一時置き場です。ページ全体コピーはヘッダーの「全コピー」を使ってください。</p>
        </section>

        <section class="block" data-tags="概要 intro">
          <h2>■ 概要</h2>
          <p>会社環境に直接データを送れない時の暫定措置として、社内周知・共有用のテキストを外部向け静的ページで公開するためのテンプレートです。GitHub Pages や Netlify にアップロードすれば、そのまま閲覧できます。</p>
          <ul>
            <li>単一ファイル（HTMLだけ）</li>
            <li>ページ内検索（上部検索ボックス）</li>
            <li>本文の一括コピー（「全コピー」ボタン）</li>
            <li>noindex切替（「noindex切替」ボタン）</li>
          </ul>
        </section>

        <section class="block" data-tags="連絡事項 notes">
          <h2>■ 連絡事項</h2>
          <p>ここに連絡事項を列挙します。箇条書きや段落を追加してください。</p>
        </section>

        <section class="block" data-tags="詳細 details">
          <h2>■ 詳細</h2>
          <details>
            <summary>サンプル：補足の折りたたみ</summary>
            <pre><code>サンプルログ: 2025-10-23 16:00 JST
- 実施: テストX
- 結果: OK</code></pre>
          </details>
        </section>

        <section class="block" data-tags="リンク links">
          <h2>■ 関連リンク</h2>
          <ul>
            <li><a href="#" rel="noopener noreferrer">社内Wiki（例）</a></li>
            <li><a href="#" rel="noopener noreferrer">問い合わせフォーム（例）</a></li>
          </ul>
          <p class="tag">※ 外部公開が不都合なURLは貼らないでください。</p>
        </section>

        <!-- ↑↑↑ ここまで自由に追記OK ↑↑↑ -->
      </article>

      <footer>
        <p>&copy; 2025 テキスト公開ページ（単一HTML）</p>
      </footer>
    </main>
  </div>

  <script>
    // 表示用の更新日時
    const updatedEl = document.getElementById('updated');
    const now = new Date();
    const fmt = new Intl.DateTimeFormat('ja-JP', { dateStyle: 'full', timeStyle: 'short' }).format(now);
    updatedEl.textContent = fmt;

    // noindex のON/OFF表示
    const indexStateEl = document.getElementById('indexState');
    const robotsMeta = document.querySelector('meta[name="robots"]');
    function refreshIndexState(){
      const off = !!robotsMeta && /noindex/i.test(robotsMeta.getAttribute('content'));
      indexStateEl.textContent = `検索エンジン: ${off ? 'インデックスOFF（noindex）' : 'インデックスON'}`;
    }
    refreshIndexState();

    // noindex切替
    document.getElementById('toggleIndex').addEventListener('click', () => {
      const head = document.querySelector('head');
      const existing = document.querySelector('meta[name="robots"]');
      if (existing) existing.remove();
      else {
        const m = document.createElement('meta');
        m.setAttribute('name','robots');
        m.setAttribute('content','noindex,nofollow');
        head.appendChild(m);
      }
      refreshIndexState();
    });

    // 全文コピー
    document.getElementById('copyAll').addEventListener('click', async () => {
      const text = document.getElementById('content').innerText;
      try {
        await navigator.clipboard.writeText(text);
        const btn = document.getElementById('copyAll');
        const prev = btn.textContent; btn.textContent = 'コピーしました';
        setTimeout(() => btn.textContent = prev, 1400);
      } catch (e) { alert('コピーに失敗しました: ' + e); }
    });

    // ページ内検索（.block単位でフィルタ）
    const q = document.getElementById('q');
    q.addEventListener('input', () => {
      const v = q.value.trim().toLowerCase();
      const blocks = document.querySelectorAll('.block');
      blocks.forEach(b => {
        const hay = (b.textContent + ' ' + (b.getAttribute('data-tags')||'')).toLowerCase();
        b.style.display = hay.includes(v) ? '' : 'none';
      });
    });

    // 入力枠（貼り付け専用）のユーティリティ
    const box = document.getElementById('pasteBox');
    const info = document.getElementById('boxInfo');
    const copyBoxBtn = document.getElementById('copyBox');
    const selectBoxBtn = document.getElementById('selectBox');
    const downloadBoxBtn = document.getElementById('downloadBox');
    if (box) {
      const tell = (msg) => { info.textContent = msg; setTimeout(()=> info.textContent = '', 1600); };
      copyBoxBtn?.addEventListener('click', async () => {
        try { await navigator.clipboard.writeText(box.value); tell('コピーしました'); }
        catch(e){ alert('コピーに失敗しました: ' + e); }
      });
      selectBoxBtn?.addEventListener('click', () => { box.focus(); box.select(); tell('全選択しました'); });
      downloadBoxBtn?.addEventListener('click', () => {
        const blob = new Blob([box.value], {type:'text/plain;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'payload.txt'; a.click();
        setTimeout(()=> URL.revokeObjectURL(url), 1000);
      });
    }
  </script>
</body>
</html>
